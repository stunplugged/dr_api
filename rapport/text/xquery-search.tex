
\section{Find alle kategorierne til programserierne}
Brugeren af videoapplikationen skal have muligheden for at navigere igennem de forskellige 
programseries kategorierne der findes på tidspunktet. Funktionen i Figur \ref{xquerySearch:getProgramSeriesCategory} bruger en XPath udryk til at finde alle kategori navne i filen og funktionen distinct-value() selekterer kun unik navne. En for lykke returnerer kategorinavne som element med tag \textless category\textgreater og udover returnerer funktionen getProgramSeriesCategory() et element, \textless countCategory\textgreater, med antal af forskellige kategorier. 


\begin{figure}[ht]
%\centering
\begin{lstlisting}[style=FAKE_XQUERY, language=XQUERY]

declare function dr:getProgramSeriesCategory
  ( $programseriesFileName as xs:string) as element()*{
    
    let $progSerieLables := distinct-values(doc($programseriesFileName)/ArrayOfProgramSerie/ProgramSerie/Labels/
    	string/text())
    return (
      <countCategory>{count($progSerieLables)}</countCategory>,
      (
      for $lable in $progSerieLables
        return <category>{$lable}</category>
      )
    )
};

\end{lstlisting}
\caption{Funktion til at finde navn af programserierne og samlet antal.}
\label{xquerySearch:getProgramSeriesCategory}
\end{figure}



\section{Find antal programserier pr. kategori}
Når en bruger vægler et kategoriet skal videoapplikationen viser antallet af programserier i kategoriet og forskellige informationer om de. I funktionen \ref{xquerySearch:programSeriesOfCategory} finder den XPath udryk alle ProgramSerie elementer hvor element \textless string\textgreater i element \textless Labels\textgreater har den sammen værdi som det valgte kategori. Variablen \$progSeries holder en sekvens med alle fundet ProgramSerie elementer og ikke kun elementet \textless Labels\textgreater fordi /.. ved slutning af sekvensen vælger forældre elementet som er ProgramSerie. Den XQuery funktion count() taler antal af fundet ProgramSerie elementer. Denne information og alle de fundet ProgramSerie elementer bliver returneret i elementet \textless programSeriesCategory>.

\begin{figure}[ht]
%\centering
\begin{lstlisting}[style=FAKE_XQUERY, language=XQUERY]

declare function dr:programSeriesOfCategory
  ( $programseriesFileName as xs:string, $category as xs:string ) as element()*{
    
    let $progSeries := doc($programseriesFileName)/ArrayOfProgramSerie/
    ProgramSerie/Labels[string=$category]/..
    return (
      <programSeriesCategory>
        <nameCategory>{$category}</nameCategory>
        <countProgSeries>{count($progSeries)}</countProgSeries>
        {
         for $progSerie in $progSeries
           return $progSerie
         }
      </programSeriesCategory>
    )
};

\end{lstlisting}
\caption{Funktion til at finde alle programserierne af kategoriet og samlet antal.}
\label{xquerySearch:programSeriesOfCategory}
\end{figure}



\section{Find alle videoer med i en specifik kategori}

For at præsenterer detaljeret video informationer når en bruger har valgt et kategoriet er det nødvendig at hende denne information fra xml dokumentet. Video informationer ligger ikke i det sammen xml dokument hvor informationen om programserie og kategorier er gemmt. I denne eksempel findes kategori informationer i filen programseries.xml og video informationen i filen all.xml. En unik video ID som hedder \textless NewestVideoId\textgreater i filen programseries.xml og \textless Id\textgreater i filen all.xml referencerer fra et programserie element til en ProgramSerieVideo element. Her vises sig en svaghed af XML som ikke har nogle constrains på data indholdet (f.eks. uniknes) og referencering mellem elementerne. Faktisk er der ingen information i begge to XML dokumenterne ellers XML skemaer som dokumenterer denne reference mellem begge to tags.
Til søgning after alle programserier i en specifik kategori eksisterer allerede en funktion og hedder programSeriesOfCategory() og er vist i Figur \ref{xquerySearch:programSeriesOfCategory}. Denne funktion blev kald i funktionen videosOfCategory() i Figur \ref(xquerySearch:videosOfCategory). Den resulterende sekvens indholder alle fundet programserie elementer som igen har den søgte tag \textless NewestVideoId\textgreater. En for lykke behandler de programserie elementer og en XPath udryk selekterer kun den unik video ID som blev gemt i en variable \$videoId. I den samme for lykke bliver \$videoId brugt som en argument i en anden XPath søgning, men denne gang i video XML filen. Resultatet af søgning er programserie video informationer og bliver returneret af funktionen.


\begin{figure}[ht]
%\centering
\begin{lstlisting}[style=FAKE_XQUERY, language=XQUERY]

declare function dr:videosOfCategory
( $programseriesFileName as xs:string,  $programseriesVideoFileName as xs:string, $category as xs:string ) as element()*{

  let $programSeriesCategory := dr:programSeriesOfCategory($programseriesFileName, $category )
  return(
    for $videoId in $programSeriesCategory//ProgramSerie/NewestVideoId/data()
      return(
        let $programSerieVideo := doc($programseriesVideoFileName)//ProgramSerieVideo[Id = $videoId]
        return $programSerieVideo
      )
  )
};
\end{lstlisting}
\caption{Funktion til at finde alle videoer i en specifik kategoriet.}
\label{xquerySearch:videosOfCategory}
\end{figure}




\section{Find alle videoer inden for et specifikt tidsinterval}

Videoapplikationen skal have en søgefunktion hvor brugeren kan finde programserievideoer hvor udsendelse tidspunkt ligger inden for et specifikt tidsinterval. XQuery funktionen er vist i Figur \ref{xquerySearch:programSeriesVideoBroadcastDateInterval} og tager navnet af XML video filen, start og stop tidspunktet som argument. En for lykke læser tidsinformation i tagget \textless BroadcastTime\textgreater af hvert element ProgramSerieVideo og returnerer kun de ProgramSerieVideo elementer hvor udsendelse tidspunktet ligger inden for tidsintervallet. XQuery har to forskellige sammenligningsoperatorer, værdier sammenligningsoperatorer (f.eks. le, ge) som er beregnet til at sammenligne enkelte værdi og generelte sammenligningsoperatorer (f.eks. \textless =, =\textgreater) for at sammenligne sekvenser med flere værdier. I denne funktion blev brugt de første variant fordi der er kun enkelte værdier som skal sammenlignes. Det er nødvendig at tage højde for at tagget \textless BroadcastTime\textgreater kan være tomt. I denne situation vil cast fra null til xs:dateTime() giver en dynamisk fejl. XQuery er et funktionelt programmeringssprog og der medfølges at variabler er uforanderlig. Derfor bruges en hjælpefunktion, Figur \ref{xquerySearch:getBroadCastTime} som kontrollerer når tagget er tomt og dermed returnere en dummy date ("1900-01-01T00:00:00") ellers den fundet date, til at opdatere den interne variable \$broadCastTime.


\begin{figure}[ht]
%\centering
\begin{lstlisting}[style=FAKE_XQUERY, language=XQUERY]

declare function dr:programSeriesVideoBroadcastDateInterval
( $programseriesVideoFileName as xs:string, $dateStart as xs:dateTime, $dateStop as xs:dateTime) as element()*{
  for $progSerVideoElement in doc($programseriesVideoFileName)/ArrayOfProgramSerieVideo/ProgramSerieVideo
  let $broadCastTime := dr:getBroadCastTime($progSerVideoElement/BroadcastTime)
  where $broadCastTime ge $dateStart and $broadCastTime le $dateStop
  return $progSerVideoElement
}; 

\end{lstlisting}
\caption{Funktion til at finde videoer for et specifikt tidsinterval}
\label{xquerySearch:programSeriesVideoBroadcastDateInterval}
\end{figure}



\begin{figure}[ht]
%\centering
\begin{lstlisting}[style=FAKE_XQUERY, language=XQUERY]

declare function dr:getBroadCastTime
($broadCastTimeElement as element() ) as xs:dateTime{
  if( not($broadCastTimeElement/data()) ) then (
       (xs:dateTime("1900-01-01T00:00:00"))
    ) else (
      (xs:dateTime($broadCastTimeElement/data()))
    ) 
};

\end{lstlisting}
\caption{Funktion til at læse BroadcastTime}
\label{xquerySearch:getBroadCastTime}
\end{figure}





%TODO: Insert stuff about xquery search

% Description of each search and how it is solved

% Done! Find programs between specific date intervals.
% Done! Find all kinds of labels for prorgams.
% Done! Find the number of programs for each label.

% Identisk! Find all kinds of broadcasting channels.
% Find the number of programs for each channel.

% Find all videos from a particular series of programs sorted by date.



